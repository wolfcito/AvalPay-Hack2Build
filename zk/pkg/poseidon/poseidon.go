package poseidon

import (
	"math/big"

	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/hash"
)

func Sigma(api frontend.API, in frontend.Variable) frontend.Variable {
	in2 := api.Mul(in, in)
	in4 := api.Mul(in2, in2)
	return api.Mul(in4, in)
}

func Ark(api frontend.API, in []frontend.Variable, c []*big.Int, r int) []frontend.Variable {
	out := make([]frontend.Variable, len(in))
	for i, v := range in {
		out[i] = api.Add(v, c[i+r])
	}
	return out
}

func Mix(api frontend.API, in []frontend.Variable, m [][]*big.Int) []frontend.Variable {
	t := len(in)
	out := make([]frontend.Variable, t)
	for i := 0; i < t; i++ {
		lc := frontend.Variable(0)
		for j := 0; j < t; j++ {
			lc = api.Add(lc, api.Mul(m[j][i], in[j]))
		}
		out[i] = lc
	}
	return out
}

func MixLast(api frontend.API, in []frontend.Variable, m [][]*big.Int, s int) frontend.Variable {
	t := len(in)
	out := frontend.Variable(0)
	for j := 0; j < t; j++ {
		out = api.Add(out, api.Mul(m[j][s], in[j]))
	}
	return out
}

func MixS(api frontend.API, in []frontend.Variable, s []*big.Int, r int) []frontend.Variable {
	t := len(in)
	out := make([]frontend.Variable, t)
	lc := frontend.Variable(0)
	for i := 0; i < t; i++ {
		lc = api.Add(lc, api.Mul(s[(t*2-1)*r+i], in[i]))
	}
	out[0] = lc
	for i := 1; i < t; i++ {
		out[i] = api.Add(in[i], api.Mul(in[0], s[(t*2-1)*r+t+i-1]))
	}
	return out
}

func PoseidonEx(api frontend.API, inputs []frontend.Variable, initialState frontend.Variable, nOuts int) []frontend.Variable {
	nInputs := len(inputs)
	out := make([]frontend.Variable, nOuts)

	// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
	// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
	// And rounded up to nearest integer that divides by t
	nRoundsPC := [16]int{56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68}
	t := nInputs + 1
	nRoundsF := 8
	nRoundsP := nRoundsPC[t-2]
	c := POSEIDON_C(t)
	s := POSEIDON_S(t)
	m := POSEIDON_M(t)
	p := POSEIDON_P(t)

	state := make([]frontend.Variable, t)
	for j := 0; j < t; j++ {
		if j == 0 {
			state[0] = initialState
		} else {
			state[j] = inputs[j-1]
		}
	}
	state = Ark(api, state, c, 0)

	for r := 0; r < nRoundsF/2-1; r++ {
		for j := 0; j < t; j++ {
			state[j] = Sigma(api, state[j])
		}
		state = Ark(api, state, c, (r+1)*t)
		state = Mix(api, state, m)
	}

	for j := 0; j < t; j++ {
		state[j] = Sigma(api, state[j])
	}
	state = Ark(api, state, c, nRoundsF/2*t)
	state = Mix(api, state, p)

	for r := 0; r < nRoundsP; r++ {

		state[0] = Sigma(api, state[0])
		state[0] = api.Add(state[0], c[(nRoundsF/2+1)*t+r])

		newState0 := frontend.Variable(0)
		for j := 0; j < len(state); j++ {
			mul := api.Mul(s[(t*2-1)*r+j], state[j])
			newState0 = api.Add(newState0, mul)
		}

		for k := 1; k < t; k++ {
			state[k] = api.Add(state[k], api.Mul(state[0], s[(t*2-1)*r+t+k-1]))
		}
		state[0] = newState0
	}

	for r := 0; r < nRoundsF/2-1; r++ {
		for j := 0; j < t; j++ {
			state[j] = Sigma(api, state[j])
		}
		state = Ark(api, state, c, (nRoundsF/2+1)*t+nRoundsP+r*t)
		state = Mix(api, state, m)
	}

	for j := 0; j < t; j++ {
		state[j] = Sigma(api, state[j])
	}

	for i := 0; i < nOuts; i++ {
		out[i] = MixLast(api, state, m, i)
	}
	return out
}

type poseidonHash struct {
	api    frontend.API
	data   []frontend.Variable
	status frontend.Variable
}

func NewPoseidonHash(api frontend.API) hash.FieldHasher {
	return &poseidonHash{
		api:    api,
		status: frontend.Variable(0),
		data:   []frontend.Variable{},
	}
}

func (m *poseidonHash) Sum() frontend.Variable {
	r := PoseidonEx(m.api, m.data, 0, 1)
	m.status = r[0]

	return m.status
}

func (m *poseidonHash) Write(data ...frontend.Variable) {
	m.data = append(m.data, data...)
}

func (m *poseidonHash) Reset() {
	m.data = nil
	m.status = 0
}

// ------------------------------------------------------------
// Evacy 2.0 ASC function
// ------------------------------------------------------------
// Description:
// ------------------------------------------------------------
// GenerateASC is a function that takes an API object, an address (of the sender), a randomizer  (for extra security), negative balance, and a deposit (positive) balance as frontend variables, and returns
// an output Account State Commitment (ASC) which is the Poseidon hash of the inputs (plus the fixed ASC key "91190172").
// ------------------------------------------------------------
// Parameters:
// ------------------------------------------------------------
// - addr: a frontend.Variable representing the address of the sender's account
// - negBalance: a frontend.Variable representing the negative balance of the sender's account
// - depBalance: a frontend.Variable representing the deposit balance of the sender's account
// - random: a frontend.Variable representing a randomly generated value used in the account state commitment
// ------------------------------------------------------------
// Returns:
// ------------------------------------------------------------
// ASC: A frontend.Variable representing the output of the Poseidon hash function, which serves as the ASC of the account.
// ------------------------------------------------------------
func GenerateASC(m hash.FieldHasher, address, negativeBalance, depositBalance, random frontend.Variable) frontend.Variable {
	ascKey := frontend.Variable("91190172")
	m.Reset()
	m.Write(address, negativeBalance, depositBalance, ascKey, random)
	res := m.Sum()

	// need to reset before returning
	m.Reset()
	return res
}

// generates the address of an account from the public key
// Address = CRH(Pk.X, Pk.Y)
func GenerateAddress(m hash.FieldHasher, x, y frontend.Variable) frontend.Variable {
	m.Reset()
	m.Write(x, y)
	res := m.Sum()

	// need to reset before returning
	m.Reset()
	return res
}

// generates the nullifier for the account state
// Nullifier = CRH(accountState, senderSk)
func GenerateNullifier(m hash.FieldHasher, accountState, senderSk frontend.Variable) frontend.Variable {
	m.Reset()
	m.Write(accountState, senderSk)
	res := m.Sum()

	// need to reset before returning
	m.Reset()
	return res
}

// function takes encrypted balance as input and
// hash the balance to get the inflow leaf
func CalculateInflowLeaf(api frontend.API, encryptedBalance [][4]frontend.Variable, h hash.FieldHasher) frontend.Variable {
	h.Reset()

	ins := make([]frontend.Variable, 3)

	for i := 0; i < len(encryptedBalance); i++ {
		h.Write(encryptedBalance[i][:]...)
		ins[i] = h.Sum()
		h.Reset()
	}

	h.Write(ins[:]...)
	out := h.Sum()
	h.Reset()
	return out
}

// function verifies a non-fixed sized merkle proof
// if pathElement[i] = 0, then leaf is not used in the hash and skip
// accordingly
func VerifyNonFixedMerkleProof(
	api frontend.API,
	leaf, root frontend.Variable,
	pathElements, pathIndices [64]frontend.Variable,
	h hash.FieldHasher,
) {
	// 1. Compute the hash of the leaf and first path element
	out := nodeSum(api, leaf, pathElements[0], pathIndices[0], h)

	// 2. Compute the hash of the remaining path elements with indices
	for i := 1; i < 64; i++ {
		out = api.Select(api.IsZero(pathElements[i]), out, nodeSum(api, out, pathElements[i], pathIndices[i], h))
	}

	// 3. Assert that the calculated root matches the expected root
	api.AssertIsEqual(root, out)
}

// function to compute the hash of two nodes
// helper for verifying merkle proofs
func nodeSum(api frontend.API, leaf1, leaf2, index frontend.Variable, h hash.FieldHasher) frontend.Variable {
	DualMux := func(api frontend.API, inputs [2]frontend.Variable, index frontend.Variable) [2]frontend.Variable {
		api.AssertIsBoolean(index)

		diff := api.Sub(inputs[1], inputs[0])
		diffMulS := api.Mul(diff, index)

		negDiff := api.Sub(inputs[0], inputs[1])
		negDiffMulS := api.Mul(negDiff, index)

		out0 := api.Add(inputs[0], diffMulS)
		out1 := api.Add(inputs[1], negDiffMulS)

		return [2]frontend.Variable{out0, out1}
	}

	in := DualMux(api, [2]frontend.Variable{leaf1, leaf2}, index)

	h.Reset()
	h.Write(in[0], in[1])
	return h.Sum()
}

// function returns the Poseidon hash of two input variables
func Hash2(h hash.FieldHasher, a, b frontend.Variable) frontend.Variable {
	h.Reset()
	h.Write(a, b)
	out := h.Sum()
	h.Reset()
	return out
}

func Hash3(h hash.FieldHasher, a, b, c frontend.Variable) frontend.Variable {
	h.Reset()
	h.Write(a, b, c)
	out := h.Sum()
	h.Reset()
	return out
}

func CalculateNullifierHash(h hash.FieldHasher, chainID frontend.Variable, auditorPCT []frontend.Variable) frontend.Variable {
	h.Reset()
	h.Write(append([]frontend.Variable{chainID}, auditorPCT...)...)
	out := h.Sum()
	h.Reset()
	return out
}
